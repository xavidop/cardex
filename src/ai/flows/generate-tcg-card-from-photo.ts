// This file is automatically generated - edits will be lost!
'use server';

/**
 * @fileOverview Uses DALL-E to generate TCG cards based on an uploaded photo reference.
 *
 * - generateTCGCardFromPhoto - A function that handles the photo-based card generation process.
 * - GenerateFromPhotoInput - The input type for the generateTCGCardFromPhoto function.
 * - GenerateFromPhotoOutput - The return type for the generateTCGCardFromPhoto function.
 */

import { z } from 'genkit';
import OpenAI from 'openai';
import { getUserApiKeys } from '@/lib/firestore';
import { getGameConfig } from '@/config/tcg-games';
import type { TCGGame } from '@/types';
import { tcgGameSchema, languageSchema } from '@/constants';
import {
  generatePokemonPrompt,
  generateOnePiecePrompt,
  generateLorcanaPrompt,
  generateMagicPrompt,
  generateDragonBallPrompt,
} from '@/ai/prompts/game-prompts';

const GenerateFromPhotoInputSchema = z.object({
  userId: z.string().min(1, "User ID is required"),
  game: tcgGameSchema,
  photoDataUri: z
    .string()
    .describe(
      "A reference photo as a data URI that must include a MIME type and use Base64 encoding. Expected format: 'data:<mimetype>;base64,<encoded_data>'."
    ),
  characterName: z.string().min(1, "Character name is required"),
  characterType: z.string().min(1, "Character type is required"),
  styleDescription: z.string().min(10, "Style description is required - describe how to adapt the photo"),
  language: languageSchema.default('english'),
  
  // Game-specific stats (all optional)
  hp: z.number().optional(),
  attackName1: z.string().optional(),
  attackDamage1: z.number().optional(),
  attackName2: z.string().optional(),
  attackDamage2: z.number().optional(),
  weakness: z.string().optional(),
  resistance: z.string().optional(),
  retreatCost: z.number().optional(),
  power: z.number().optional(),
  cost: z.number().optional(),
  counter: z.number().optional(),
  lifePoints: z.number().optional(),
  inkCost: z.number().optional(),
  strength: z.number().optional(),
  willpower: z.number().optional(),
  lore: z.number().optional(),
  inkable: z.boolean().optional(),
  manaCost: z.string().optional(),
  cardType: z.string().optional(),
  subType: z.string().optional(),
  powerToughness: z.string().optional(),
  combatPower: z.number().optional(),
  comboCost: z.number().optional(),
  comboEnergy: z.number().optional(),
  era: z.string().optional(),
});

export type GenerateFromPhotoInput = z.infer<typeof GenerateFromPhotoInputSchema>;

const GenerateFromPhotoOutputSchema = z.object({
  imageBase64: z.string().describe("The generated card image as base64 string").optional(),
  prompt: z.string().describe("The prompt used to generate the card").optional(),
  error: z.string().describe("Error message if the card could not be generated").optional()
});

export type GenerateFromPhotoOutput = z.infer<typeof GenerateFromPhotoOutputSchema>;

export async function generateTCGCardFromPhoto(input: GenerateFromPhotoInput): Promise<GenerateFromPhotoOutput> {
  try {
    // Get user's API keys from Firestore
    const userApiKeys = await getUserApiKeys(input.userId);
    const apiKey = userApiKeys?.openaiApiKey || process.env.OPENAI_API_KEY;
    
    if (!apiKey) {
      return { 
        error: 'OpenAI API key is required. Please configure your API key in Settings or set OPENAI_API_KEY environment variable.' 
      };
    }

    const openai = new OpenAI({
      apiKey: apiKey,
    });

    const gameConfig = getGameConfig(input.game as TCGGame);
    console.log(`Generating ${gameConfig.name} card using reference photo...`);
    
    // Generate the enhanced prompt for the card
    const enhancedPrompt = generatePhotoBasedCardPrompt(input);
    console.log("Generated prompt for image generation:", enhancedPrompt);

    // Use OpenAI responses.create with reference image for image generation
    const response = await openai.responses.create({
      model: "gpt-5",
      input: [
        {
          role: "user",
          content: [
            { type: "input_text", text: enhancedPrompt },
            {
              type: "input_image",
              image_url: input.photoDataUri,
              detail: "high"
            },
          ],
        },
      ],
      tools: [{ type: "image_generation" }],
    });

    const imageData = response.output
      .filter((output) => output.type === "image_generation_call")
      .map((output) => output.result);

    if (imageData.length > 0) {
      const imageBase64 = imageData[0];
      return {
        imageBase64: imageBase64 || "",
        prompt: enhancedPrompt,
      };
    } else {
      console.log("No image generated, response output:", response.output);
      return { error: 'No image generated from the reference photo.' };
    }
  } catch (error: any) {
    console.error('Error generating card from photo:', error);
    return { error: `Failed to generate card: ${error?.message || 'Unknown error'}` };
  }
}

function generatePhotoBasedCardPrompt(params: GenerateFromPhotoInput): string {
  const gameConfig = getGameConfig(params.game as TCGGame);
  const gameName = gameConfig.name;
  
  const {
    game,
    characterName,
    characterType,
    styleDescription,
    language,
  } = params;

  const languageInstruction = language !== 'english' ? `Write all card information in ${language}.` : '';

  let gameSpecificPrompt = '';
  
  switch (game) {
    case 'pokemon':
      gameSpecificPrompt = generatePokemonPrompt({
        characterName: params.characterName,
        characterType: params.characterType,
        hp: params.hp,
        attackName1: params.attackName1,
        attackDamage1: params.attackDamage1,
        attackName2: params.attackName2,
        attackDamage2: params.attackDamage2,
        weakness: params.weakness,
        resistance: params.resistance,
        retreatCost: params.retreatCost,
        language: params.language,
      });
      break;
    case 'onepiece':
      gameSpecificPrompt = generateOnePiecePrompt({
        characterName: params.characterName,
        characterType: params.characterType,
        power: params.power,
        cost: params.cost,
        counter: params.counter,
      });
      break;
    case 'lorcana':
      gameSpecificPrompt = generateLorcanaPrompt({
        characterName: params.characterName,
        characterType: params.characterType,
        inkCost: params.inkCost,
        strength: params.strength,
        willpower: params.willpower,
        lore: params.lore,
        inkable: params.inkable,
      });
      break;
    case 'magic':
      gameSpecificPrompt = generateMagicPrompt({
        characterName: params.characterName,
        characterType: params.characterType,
        manaCost: params.manaCost,
        cardType: params.cardType,
        subType: params.subType,
        powerToughness: params.powerToughness,
      });
      break;
    case 'dragonball':
      gameSpecificPrompt = generateDragonBallPrompt({
        characterName: params.characterName,
        characterType: params.characterType,
        combatPower: params.combatPower,
        comboCost: params.comboCost,
        comboEnergy: params.comboEnergy,
        era: params.era,
      });
      break;
  }

  return `Create a professional ${gameName} trading card featuring "${characterName}".

IMPORTANT: Use the reference photo as inspiration and adapt it to create a trading card illustration. Use the base photo, but in Studio Ghibli style, ${styleDescription}

The card should be a ${characterType} type and follow the authentic ${gameName} card design with proper layout, fonts, and formatting.

${gameSpecificPrompt}

${languageInstruction}

The final output must look like an authentic ${gameName} trading card with all text clearly legible and properly formatted. Make sure the information is displayed clearly and the character illustration feels natural within the adapted photographic style.`;
}
