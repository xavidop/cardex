// This file is automatically generated - edits will be lost!
'use server';

/**
 * @fileOverview Uses DALL-E to generate TCG cards based on an uploaded photo reference.
 *
 * - generateTCGCardFromPhoto - A function that handles the photo-based card generation process.
 * - GenerateFromPhotoInput - The input type for the generateTCGCardFromPhoto function.
 * - GenerateFromPhotoOutput - The return type for the generateTCGCardFromPhoto function.
 */

import { z } from 'genkit';
import OpenAI from 'openai';
import { getUserApiKeys } from '@/lib/firestore';
import { getGameConfig } from '@/config/tcg-games';
import type { TCGGame } from '@/types';

const GenerateFromPhotoInputSchema = z.object({
  userId: z.string().min(1, "User ID is required"),
  game: z.enum(['pokemon', 'onepiece', 'lorcana', 'magic', 'dragonball']),
  photoDataUri: z
    .string()
    .describe(
      "A reference photo as a data URI that must include a MIME type and use Base64 encoding. Expected format: 'data:<mimetype>;base64,<encoded_data>'."
    ),
  characterName: z.string().min(1, "Character name is required"),
  characterType: z.string().min(1, "Character type is required"),
  styleDescription: z.string().min(10, "Style description is required - describe how to adapt the photo"),
  language: z.enum(['english', 'japanese', 'chinese', 'korean', 'spanish', 'french', 'german', 'italian']).default('english'),
  
  // Game-specific stats (all optional)
  hp: z.number().optional(),
  attackName1: z.string().optional(),
  attackDamage1: z.number().optional(),
  attackName2: z.string().optional(),
  attackDamage2: z.number().optional(),
  weakness: z.string().optional(),
  resistance: z.string().optional(),
  retreatCost: z.number().optional(),
  power: z.number().optional(),
  cost: z.number().optional(),
  counter: z.number().optional(),
  lifePoints: z.number().optional(),
  inkCost: z.number().optional(),
  strength: z.number().optional(),
  willpower: z.number().optional(),
  lore: z.number().optional(),
  inkable: z.boolean().optional(),
  manaCost: z.string().optional(),
  cardType: z.string().optional(),
  subType: z.string().optional(),
  powerToughness: z.string().optional(),
  combatPower: z.number().optional(),
  comboCost: z.number().optional(),
  comboEnergy: z.number().optional(),
  era: z.string().optional(),
});

export type GenerateFromPhotoInput = z.infer<typeof GenerateFromPhotoInputSchema>;

const GenerateFromPhotoOutputSchema = z.object({
  imageBase64: z.string().describe("The generated card image as base64 string").optional(),
  prompt: z.string().describe("The prompt used to generate the card").optional(),
  error: z.string().describe("Error message if the card could not be generated").optional()
});

export type GenerateFromPhotoOutput = z.infer<typeof GenerateFromPhotoOutputSchema>;

export async function generateTCGCardFromPhoto(input: GenerateFromPhotoInput): Promise<GenerateFromPhotoOutput> {
  try {
    // Get user's API keys from Firestore
    const userApiKeys = await getUserApiKeys(input.userId);
    const apiKey = userApiKeys?.openaiApiKey || process.env.OPENAI_API_KEY;
    
    if (!apiKey) {
      return { 
        error: 'OpenAI API key is required. Please configure your API key in Settings or set OPENAI_API_KEY environment variable.' 
      };
    }

    const openai = new OpenAI({
      apiKey: apiKey,
    });

    const gameConfig = getGameConfig(input.game as TCGGame);
    console.log(`Generating ${gameConfig.name} card using reference photo...`);
    
    // Generate the enhanced prompt for the card
    const enhancedPrompt = generatePhotoBasedCardPrompt(input);
    console.log("Generated prompt for image generation:", enhancedPrompt);

    // Use OpenAI responses.create with reference image for image generation
    const response = await openai.responses.create({
      model: "gpt-5",
      input: [
        {
          role: "user",
          content: [
            { type: "input_text", text: enhancedPrompt },
            {
              type: "input_image",
              image_url: input.photoDataUri,
              detail: "high"
            },
          ],
        },
      ],
      tools: [{ type: "image_generation" }],
    });

    const imageData = response.output
      .filter((output) => output.type === "image_generation_call")
      .map((output) => output.result);

    if (imageData.length > 0) {
      const imageBase64 = imageData[0];
      return {
        imageBase64: imageBase64 || "",
        prompt: enhancedPrompt,
      };
    } else {
      console.log("No image generated, response output:", response.output);
      return { error: 'No image generated from the reference photo.' };
    }
  } catch (error: any) {
    console.error('Error generating card from photo:', error);
    return { error: `Failed to generate card: ${error?.message || 'Unknown error'}` };
  }
}

function generatePhotoBasedCardPrompt(params: GenerateFromPhotoInput): string {
  const gameConfig = getGameConfig(params.game as TCGGame);
  const gameName = gameConfig.name;
  
  const {
    game,
    characterName,
    characterType,
    styleDescription,
    language,
  } = params;

  const languageInstruction = language !== 'english' ? `Write all card information in ${language}.` : '';

  let gameSpecificPrompt = '';
  
  switch (game) {
    case 'pokemon':
      gameSpecificPrompt = generatePokemonPhotoPrompt(params);
      break;
    case 'onepiece':
      gameSpecificPrompt = generateOnePiecePhotoPrompt(params);
      break;
    case 'lorcana':
      gameSpecificPrompt = generateLorcanaPhotoPrompt(params);
      break;
    case 'magic':
      gameSpecificPrompt = generateMagicPhotoPrompt(params);
      break;
    case 'dragonball':
      gameSpecificPrompt = generateDragonBallPhotoPrompt(params);
      break;
  }

  return `Create a professional ${gameName} trading card featuring "${characterName}".

IMPORTANT: Use the reference photo as inspiration and adapt it to create a trading card illustration. Use the base photo, but in Studio Ghibli style, ${styleDescription}

The card should be a ${characterType} type and follow the authentic ${gameName} card design with proper layout, fonts, and formatting.

${gameSpecificPrompt}

${languageInstruction}

The final output must look like an authentic ${gameName} trading card with all text clearly legible and properly formatted. Make sure the information is displayed clearly and the character illustration feels natural within the adapted photographic style.`;
}

function generatePokemonPhotoPrompt(params: GenerateFromPhotoInput): string {
  const { characterName, characterType, hp = 130, attackName1 = "Quick Attack", attackDamage1 = 60, attackName2 = "Special Move", attackDamage2 = 90, weakness = "Fighting", resistance = "Psychic", retreatCost = 2, language = 'english' } = params;
  
  const languageNote = language !== 'english' ? `All attack names and descriptions should be written in ${language}.` : '';
  
  return `A regular classic Pokémon trading card (not full art), featuring the Pokémon "${characterName}". The card has a standard vertical layout with a detailed illustration in the main area. The Pokémon "${characterName}", a ${characterType} type, should be depicted as the main subject.

The card layout includes: The top left corner displays "${characterName}" in a stylized font, with "HP ${hp}" next to it in red. Below the Pokémon's name, the ${characterType} type symbol is clearly visible. In the lower section, the card has two attacks listed. The first attack is ${attackName1}, deals ${attackDamage1} damage. The second attack is ${attackName2}, deals ${attackDamage2} damage.

Below the attacks, the Weakness is ${weakness} (x2), Resistance is ${resistance} (-30), and Retreat Cost shows ${retreatCost} energy symbols. The bottom edge of the card features a thin line of text indicating the rarity and copyright information.

${languageNote}

The overall style should match official Pokémon TCG card design with proper fonts, layout, and professional quality artwork.`;
}

function generateOnePiecePhotoPrompt(params: GenerateFromPhotoInput): string {
  const { characterName, characterType, power = 5000, cost = 4, counter = 1000 } = params;
  
  return `Card layout: One Piece Card Game style with "${characterName}" prominently displayed. ${characterType} color indicator. Cost: ${cost}, Power: ${power}, Counter: ${counter}. Include attribute icons and ability text box.`;
}

function generateLorcanaPhotoPrompt(params: GenerateFromPhotoInput): string {
  const { characterName, characterType, inkCost = 3, strength = 2, willpower = 3, lore = 2, inkable = true } = params;
  
  return `Card layout: Disney Lorcana style with "${characterName}" as title. ${characterType} ink color. Ink cost: ${inkCost}, Strength: ${strength}, Willpower: ${willpower}, Lore: ${lore}. ${inkable ? 'Include inkwell symbol.' : 'No inkwell symbol.'}`;
}

function generateMagicPhotoPrompt(params: GenerateFromPhotoInput): string {
  const { characterName, manaCost = '{2}{G}', cardType = 'Creature', subType = 'Warrior', powerToughness = '3/3' } = params;
  
  return `Card layout: Magic: The Gathering style. Card name: "${characterName}", Mana cost: ${manaCost} in top right. Type line: "${cardType} — ${subType}". ${cardType.toLowerCase().includes('creature') ? `Power/Toughness: ${powerToughness}` : ''}`;
}

function generateDragonBallPhotoPrompt(params: GenerateFromPhotoInput): string {
  const { characterName, characterType, combatPower = 20000, comboCost = 1, comboEnergy = 5000, era = 'Universe Survival Saga' } = params;
  
  return `Card layout: Dragon Ball Super Card Game style. Character: "${characterName}", ${characterType} color. Combat Power: ${combatPower}, Combo Cost: ${comboCost}, Combo Energy: ${comboEnergy}, Era: ${era}.`;
}
