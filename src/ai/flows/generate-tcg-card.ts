// This file is automatically generated - edits will be lost!
'use server';

/**
 * @fileOverview Uses Google Imagen4 to generate custom TCG cards based on user parameters.
 *
 * - generateTCGCard - A function that handles the card generation process.
 * - GenerateTCGCardInput - The input type for the generateTCGCard function.
 * - GenerateTCGCardOutput - The return type for the generateTCGCard function.
 */

import { z } from 'genkit';
import { GoogleGenAI } from '@google/genai';
import { getUserApiKeys } from '@/lib/firestore';
import type { TCGGame } from '@/types';
import { getGameConfig } from '@/config/tcg-games';
import { tcgGameSchema, languageSchema, aiModelSchema } from '@/constants';
import {
  generatePokemonPrompt as sharedPokemonPrompt,
  generateOnePiecePrompt as sharedOnePiecePrompt,
  generateLorcanaPrompt as sharedLorcanaPrompt,
  generateMagicPrompt as sharedMagicPrompt,
  generateDragonBallPrompt as sharedDragonBallPrompt,
} from '@/ai/prompts/game-prompts';

const GenerateTCGCardInputSchema = z.object({
  userId: z.string().min(1, "User ID is required"),
  game: tcgGameSchema,
  characterName: z.string().min(1, "Character name is required"),
  characterType: z.string().min(1, "Character type is required"), 
  isSpecialArt: z.boolean(),
  isHolo: z.boolean(),
  backgroundDescription: z.string().min(1, "Background description is required"),
  characterDescription: z.string().min(1, "Character description is required"),
  language: languageSchema,
  model: aiModelSchema.default('imagen-4.0-ultra-generate-001'),
  
  // Pokemon-specific
  hp: z.number().optional(),
  attackName1: z.string().optional(),
  attackDamage1: z.number().optional(),
  attackName2: z.string().optional(),
  attackDamage2: z.number().optional(),
  weakness: z.string().optional(),
  resistance: z.string().optional(),
  retreatCost: z.number().optional(),
  
  // One Piece-specific
  power: z.number().optional(),
  cost: z.number().optional(),
  counter: z.number().optional(),
  color: z.string().optional(),
  lifePoints: z.number().optional(),
  
  // Lorcana-specific
  inkCost: z.number().optional(),
  strength: z.number().optional(),
  willpower: z.number().optional(),
  lore: z.number().optional(),
  inkable: z.boolean().optional(),
  
  // Magic-specific
  manaCost: z.string().optional(),
  cardType: z.string().optional(),
  subType: z.string().optional(),
  powerToughness: z.string().optional(),
  
  // Dragon Ball-specific
  combatPower: z.number().optional(),
  comboCost: z.number().optional(),
  comboEnergy: z.number().optional(),
  era: z.string().optional(),
});

export type GenerateTCGCardInput = z.infer<typeof GenerateTCGCardInputSchema>;

const GenerateTCGCardOutputSchema = z.object({
  imageBase64: z.string().describe("The generated card image as base64 string").optional(),
  prompt: z.string().describe("The prompt used to generate the card").optional(),
  error: z.string().describe("Error message if the card could not be generated").optional()
});

export type GenerateTCGCardOutput = z.infer<typeof GenerateTCGCardOutputSchema>;

export async function generateTCGCard(input: GenerateTCGCardInput): Promise<GenerateTCGCardOutput> {
  try {
    // Get user's API keys from Firestore
    const userApiKeys = await getUserApiKeys(input.userId);
    const apiKey = userApiKeys?.geminiApiKey || process.env.GOOGLE_GENAI_API_KEY || process.env.GEMINI_API_KEY;
    
    if (!apiKey) {
      return { 
        error: 'Gemini API key is required. Please configure your API key in Settings or set GOOGLE_GENAI_API_KEY environment variable.' 
      };
    }

    const genAI = new GoogleGenAI({
       apiKey: apiKey,
    });

    // Generate the detailed prompt for the card
    const prompt = generateCardPrompt(input);
    console.log("Generated prompt:", prompt);

    // Check if using Gemini model (for generateContentStream) or Imagen model (for generateImages)
    const isGeminiModel = input.model.startsWith('gemini-');
    
    if (isGeminiModel) {
      // Use generateContentStream for Gemini models
      const config = {
        responseModalities: ['IMAGE', 'TEXT'],
        imageConfig: {
          aspectRatio: '3:4',
          imageSize: '1K',
        },
      };
      const contents = [
        {
          role: 'user' as const,
          parts: [
            {
              text: prompt,
            },
          ],
        },
      ];

      const response = await genAI.models.generateContentStream({
        model: input.model,
        config,
        contents,
      });

      let imageBase64: string | undefined;
      
      for await (const chunk of response) {
        if (!chunk.candidates || !chunk.candidates[0].content || !chunk.candidates[0].content.parts) {
          continue;
        }
        if (chunk.candidates?.[0]?.content?.parts?.[0]?.inlineData) {
          const inlineData = chunk.candidates[0].content.parts[0].inlineData;
          imageBase64 = inlineData.data || '';
          break; // We only need the first image
        }
      }

      if (!imageBase64) {
        return { error: 'No image generated from Gemini model.' };
      }

      return {
        imageBase64,
        prompt,
      };
    } else {
      // Use generateImages for Imagen models
      const response = await genAI.models.generateImages({
        model: input.model,
        prompt: prompt,
        config: {
          numberOfImages: 1,
          outputMimeType: 'image/jpeg',
          aspectRatio: '3:4' // TCG cards are roughly 3:4 aspect ratio
        },
      });

      if (!response?.generatedImages || response.generatedImages.length === 0) {
        return { error: 'No images generated.' };
      }

      const generatedImage = response.generatedImages[0];
      if (!generatedImage?.image?.imageBytes) {
        return { error: 'Generated image data is missing.' };
      }

      return {
        imageBase64: generatedImage.image.imageBytes,
        prompt: prompt,
      };
    }
  } catch (error: any) {
    console.error('Error generating TCG card:', error);
    return { error: `Failed to generate card: ${error?.message || 'Unknown error'}` };
  }
}

function generateCardPrompt(params: GenerateTCGCardInput): string {
  const gameConfig = getGameConfig(params.game as TCGGame);
  const gameName = gameConfig.name;
  
  const {
    game,
    characterName,
    characterType,
    isSpecialArt,
    isHolo,
    backgroundDescription,
    characterDescription,
    language,
  } = params;

  const cardType = isSpecialArt ? "full art special variant" : "standard layout";
  const holoEffect = isHolo ? `The card's surface has a "holo" effect, creating a shimmering, rainbow-like reflection that highlights the character and key elements.` : "";
  const languageInstruction = language !== 'english' ? `Write all card information in ${language}. The character name, abilities, and text should be translated accordingly.` : '';

  let gameSpecificPrompt = '';
  
  switch (game) {
    case 'pokemon':
      gameSpecificPrompt = sharedPokemonPrompt({
        characterName: params.characterName,
        characterType: params.characterType,
        hp: params.hp,
        attackName1: params.attackName1,
        attackDamage1: params.attackDamage1,
        attackName2: params.attackName2,
        attackDamage2: params.attackDamage2,
        weakness: params.weakness,
        resistance: params.resistance,
        retreatCost: params.retreatCost,
        language: params.language,
      });
      break;
    case 'onepiece':
      gameSpecificPrompt = sharedOnePiecePrompt({
        characterName: params.characterName,
        characterType: params.characterType,
        power: params.power,
        cost: params.cost,
        counter: params.counter,
        lifePoints: params.lifePoints,
      });
      break;
    case 'lorcana':
      gameSpecificPrompt = sharedLorcanaPrompt({
        characterName: params.characterName,
        characterType: params.characterType,
        inkCost: params.inkCost,
        strength: params.strength,
        willpower: params.willpower,
        lore: params.lore,
        inkable: params.inkable,
      });
      break;
    case 'magic':
      gameSpecificPrompt = sharedMagicPrompt({
        characterName: params.characterName,
        characterType: params.characterType,
        manaCost: params.manaCost,
        cardType: params.cardType,
        subType: params.subType,
        powerToughness: params.powerToughness,
      });
      break;
    case 'dragonball':
      gameSpecificPrompt = sharedDragonBallPrompt({
        characterName: params.characterName,
        characterType: params.characterType,
        combatPower: params.combatPower,
        comboCost: params.comboCost,
        comboEnergy: params.comboEnergy,
        era: params.era,
      });
      break;
  }

  return `A ${cardType} collectible ${gameName} trading card, featuring "${characterName}". ${isSpecialArt ? "The illustration covers the entire card in a stunning full-art layout" : "The card has a standard vertical layout with a detailed illustration in the main area."} ${characterName}, a ${characterType} type, is depicted ${characterDescription}. The background of the illustration shows ${backgroundDescription}. ${holoEffect}

${gameSpecificPrompt}

${languageInstruction}

The overall style should match official ${gameName} card design with proper fonts, layout, and professional quality artwork.
Make sure all information is displayed clearly and legibly.
The output should just be the card itself.`;
}
