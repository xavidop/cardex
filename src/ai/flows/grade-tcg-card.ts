// This file is automatically generated - edits will be lost!
'use server';

/**
 * @fileOverview Uses Gemini Vision to grade a TCG card's condition based on PSA/BGS/CGC standards.
 *
 * - gradeTCGCard - A function that handles the card grading process.
 * - GradeTCGCardInput - The input type for the gradeTCGCard function.
 * - GradeTCGCardOutput - The return type for the gradeTCGCard function.
 */

import {ai, createUserAI} from '@/ai/genkit';
import {z} from 'genkit';
import type { TCGGame } from '@/types';
import { tcgGameSchema } from '@/constants';

const GradeTCGCardInputSchema = z.object({
  frontPhotoDataUri: z
    .string()
    .describe(
      "A photo of the front of a trading card, as a data URI that must include a MIME type and use Base64 encoding. Expected format: 'data:<mimetype>;base64,<encoded_data>'."
    ),
  backPhotoDataUri: z
    .string()
    .optional()
    .describe(
      "Optional photo of the back of the trading card, as a data URI. If provided, will be used for more accurate centering and surface grading."
    ),
  userId: z.string().describe("The user ID for personalized API key usage.").optional(),
  cardName: z.string().describe("The name of the card being graded.").optional(),
  cardSet: z.string().describe("The set the card belongs to.").optional(),
  game: tcgGameSchema.optional().describe("The TCG game this card is from."),
  gradingScale: z.enum(['PSA', 'BGS', 'CGC']).optional().describe("The grading scale to use. Default is PSA."),
});
export type GradeTCGCardInput = z.infer<typeof GradeTCGCardInputSchema>;

const GradeTCGCardOutputSchema = z.object({
  gradingResult: z.object({
    overallGrade: z.number().min(1).max(10).describe("Overall grade on a 1-10 scale."),
    centering: z.object({
      score: z.number().min(1).max(10).describe("Centering score 1-10."),
      frontCentering: z.string().describe("Front centering ratio (e.g., '55/45')."),
      backCentering: z.string().describe("Back centering ratio (e.g., '60/40')."),
      notes: z.string().describe("Notes about centering condition."),
    }).describe("Centering analysis."),
    corners: z.object({
      score: z.number().min(1).max(10).describe("Corners score 1-10."),
      condition: z.string().describe("Corners condition description."),
      notes: z.string().describe("Notes about corner condition."),
    }).describe("Corners analysis."),
    edges: z.object({
      score: z.number().min(1).max(10).describe("Edges score 1-10."),
      condition: z.string().describe("Edges condition description."),
      notes: z.string().describe("Notes about edge condition."),
    }).describe("Edges analysis."),
    surface: z.object({
      score: z.number().min(1).max(10).describe("Surface score 1-10."),
      condition: z.string().describe("Surface condition description."),
      notes: z.string().describe("Notes about surface condition."),
    }).describe("Surface analysis."),
    gradingScale: z.enum(['PSA', 'BGS', 'CGC']).describe("The grading scale used."),
    gradeName: z.string().describe("Grade name (e.g., 'GEM MINT', 'MINT', 'NEAR MINT')."),
    estimatedValue: z.string().optional().describe("Estimated market value if card info provided."),
    recommendations: z.array(z.string()).describe("Recommendations for card protection/preservation."),
    detailedAnalysis: z.string().describe("Overall detailed assessment of the card's condition."),
  }).describe("Comprehensive grading result.").optional(),
  error: z.string().describe("Error message if the card could not be graded.").optional()
});

export type GradeTCGCardOutput = z.infer<typeof GradeTCGCardOutputSchema>;

export async function gradeTCGCard(input: GradeTCGCardInput): Promise<GradeTCGCardOutput> {
  return gradeTCGCardFlow(input);
}

async function createGradePromptAndFlow(userAI: any) {
  const gradeScale = (scale: string = 'PSA') => {
    const scales = {
      PSA: `PSA Grading Scale:
- 10 (GEM MINT): Perfect card with no visible flaws
- 9 (MINT): Minor imperfections allowed
- 8 (NM-MT): Near Mint to Mint condition
- 7 (NM): Near Mint condition
- 6 (EX-MT): Excellent to Mint
- 5 (EX): Excellent condition
- 4 (VG-EX): Very Good to Excellent
- 3 (VG): Very Good condition
- 2 (GOOD): Good condition with visible wear
- 1 (POOR): Poor condition with heavy wear`,
      BGS: `Beckett Grading Scale (BGS):
- 10 (PRISTINE): Perfect in every way
- 9.5 (GEM MINT): Near perfect card
- 9 (MINT): Minor imperfections
- 8.5 (NM-MT+): Near Mint to Mint+
- 8 (NM-MT): Near Mint to Mint
- 7.5 (NM+): Near Mint+
- 7 (NM): Near Mint
- 6.5 (EX-NM+): Excellent to Near Mint+
- 6 (EX-NM): Excellent to Near Mint
- 5.5 (EX+): Excellent+
- 5 (EX): Excellent
- Lower grades for worse condition`,
      CGC: `CGC Grading Scale:
- 10 (PRISTINE): Perfect card
- 9.5 (GEM MINT): Near perfect
- 9 (MINT): Mint condition
- 8.5 (NM/MINT+): Near Mint to Mint+
- 8 (NM/MINT): Near Mint to Mint
- 7.5 (NM+): Near Mint+
- 7 (NM): Near Mint
- 6.5 (EX/NM+): Excellent to Near Mint+
- 6 (EX/NM): Excellent to Near Mint
- 5.5 (EX+): Excellent+
- 5 (EX): Excellent condition
- Lower grades for worse condition`
    };
    return scales[scale as keyof typeof scales] || scales.PSA;
  };

  const gradeTCGCardPrompt = userAI.definePrompt({
    name: 'gradeTCGCardPrompt',
    input: {schema: GradeTCGCardInputSchema},
    output: {schema: GradeTCGCardOutputSchema},
    prompt: `You are an expert trading card grading professional with extensive knowledge of PSA, BGS (Beckett), and CGC grading standards. You specialize in evaluating TCG cards including PokÃ©mon, One Piece, Lorcana, Magic: The Gathering, and Dragon Ball cards.

{{#if gradingScale}}
Use the ${gradeScale('{{gradingScale}}')} grading scale.
{{else}}
Use the ${gradeScale('PSA')} grading scale (default).
{{/if}}

Analyze the following card image(s) and provide a comprehensive grading assessment:

Front Photo: {{media url=frontPhotoDataUri}}
{{#if backPhotoDataUri}}
Back Photo: {{media url=backPhotoDataUri}}
{{/if}}

{{#if cardName}}
Card Name: {{cardName}}
{{/if}}
{{#if cardSet}}
Card Set: {{cardSet}}
{{/if}}
{{#if game}}
Game: {{game}}
{{/if}}

{{#if backPhotoDataUri}}
Note: Both front and back images are provided. Use both images to provide a more accurate assessment of centering, surface quality, and overall condition.
{{else}}
Note: Only front image provided. Estimate back centering and condition based on typical manufacturing tolerances.
{{/if}}

GRADING CRITERIA TO EVALUATE:

1. **CENTERING** (Front and Back):
   - Measure the borders on all four sides
   - Front centering should be within specific tolerances (e.g., 60/40 for PSA 9, 55/45 for PSA 10)
   - Back centering has slightly more tolerance
   - Provide specific ratios (e.g., "55/45" for left-right, top-bottom)

2. **CORNERS**:
   - Examine all four corners for wear, whitening, or rounding
   - Sharp corners = higher grade
   - Any fraying, bending, or whitening reduces the grade
   - Note which corners (if any) show issues

3. **EDGES**:
   - Check all four edges for wear, chipping, or roughness
   - Look for whitening along edges
   - Clean, sharp edges = higher grade
   - Note any specific edge issues

4. **SURFACE**:
   - Look for scratches, print lines, print dots
   - Check for indentations, creases, or wrinkles
   - Evaluate holographic surface quality (if applicable)
   - Look for any staining or discoloration
   - Note any surface imperfections

IMPORTANT GRADING RULES:
- A card can only be as good as its worst attribute
- Centering issues often limit the maximum grade
- Surface defects can significantly drop the grade
- Be realistic and conservative in grading
- Corner and edge wear are critical factors

Provide your assessment in the following JSON format:
{
  "gradingResult": {
    "overallGrade": 8.5,
    "centering": {
      "score": 9,
      "frontCentering": "55/45",
      "backCentering": "60/40",
      "notes": "Front centering is excellent, back slightly off-center left to right"
    },
    "corners": {
      "score": 8,
      "condition": "Mostly sharp with minor wear",
      "notes": "Top right corner shows slight whitening, other corners are sharp"
    },
    "edges": {
      "score": 9,
      "condition": "Clean with minimal wear",
      "notes": "Edges are clean and sharp with no visible whitening"
    },
    "surface": {
      "score": 8,
      "condition": "Minor imperfections visible",
      "notes": "Small print line visible near top edge, holographic surface shows minor wear"
    },
    "gradingScale": "PSA",
    "gradeName": "NM-MT",
    "estimatedValue": "$50-75 (based on condition)",
    "recommendations": [
      "Store in a penny sleeve and top loader",
      "Keep away from direct sunlight",
      "Consider professional grading if valuable",
      "Handle with clean hands or gloves"
    ],
    "detailedAnalysis": "This card presents in Near Mint to Mint condition with excellent centering and clean edges. The primary factors preventing a higher grade are the slight corner wear on the top right corner and a minor print line on the surface. Overall, this is a well-preserved card that would likely grade PSA 8-8.5. With proper storage, it should maintain its condition."
  }
}

If the image is unclear, not a trading card, or cannot be properly graded, respond with:
{
  "error": "Unable to grade card. [Specific reason: image too blurry, not a trading card, etc.]"
}`,
  });

  const gradeTCGCardFlow = userAI.defineFlow(
    {
      name: 'gradeTCGCardFlow',
      inputSchema: GradeTCGCardInputSchema,
      outputSchema: GradeTCGCardOutputSchema,
    },
    async (input: GradeTCGCardInput) => {
      try {
        const {output} = await gradeTCGCardPrompt(input);
        return output!;
      } catch (error: any) {
        console.error('Error during card grading:', error);
        return {error: 'Failed to grade trading card.'};
      }
    }
  );

  return gradeTCGCardFlow;
}

const gradeTCGCardFlow = ai.defineFlow(
  {
    name: 'gradeTCGCardFlow',
    inputSchema: GradeTCGCardInputSchema,
    outputSchema: GradeTCGCardOutputSchema,
  },
  async (input: GradeTCGCardInput) => {
    try {
      const userAI = await createUserAI(input.userId || '');
      const flow = await createGradePromptAndFlow(userAI);
      return await flow(input);
    } catch (error: any) {
      console.error('Error during card grading:', error);
      return {error: 'Failed to grade trading card.'};
    }
  }
);
